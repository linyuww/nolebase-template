## 关于inline函数

```cpp
class Person
{
public:
	Person(const string &name)
	{
		Name = name;
	}
    void printName();
	//在类里面没有显式声明
private:
	string Name;
};
void Person::printName()//不是内联函数
{//在类外面也没有显式定义
	cout << Name << endl;
}
```

[C++类里面的哪些成员函数是内联函数？_操作符函数是内联的吗-CSDN博客](https://blog.csdn.net/qq_18343569/article/details/83755202)

## 关于友元类和友元函数

- 友元关系是单向的，不具有交换性。

- 友元关系不能传递

- 友元关系不能被继承，但对已有的方法来说访问权限不改变。

- 类A把类B声明为友元类，在前面要有前置声明

- 类A把类B中的函数声明为友元函数，在类A之前必须有类B的完整定义

  ```cpp
  class Date; // 前置声明
  class Time
  {
      friend class Date; 
      // 声明日期类为时间类的友元类，则在日期类中就直接访问Time类中的私有成员变量
  public:
      Time(int hour, int minute, int second): _hour(hour), _minute(minute), _second(second)
      {}
   
  private:
      int _hour;
      int _minute;
      int _second;
  };
   
  class Date
  {
  public:
      Date(int year = 1900, int month = 1, int day = 1): _year(year),                                     
      _month(month),_day(day)
      {}
      void SetTimeOfDate(int hour, int minute, int second)
      {
          // 直接访问时间类私有的成员变量
          _t._hour = hour;
          _t._minute = minute;
          _t.second = second;
      }
  private:
      int _year;
      int _month;
      int _day;
      Time _t;
  };
  ```

  重载输出运算符设置为全局函数

**为什么输出运算符重载不能是一个成员函数?而非得声明为友元？**
原因如下：

```csharp
 返回值 operator运算符(参数列表){}
```

重载运算符时，函数声明在类内和类外是有区别的，比方说 + - * / 等需要2个操作数的运算符，当声明在类的外部时，则参数列表为2个参数，第一个参数为运算符左边的操作数，而第二个参数为操作符右边的操作数：如下

```csharp
classType operator+(classType& left, classType& right);
```

而当函数声明在类的内部时，即为类的成员函数时，

```csharp
classType operator+(classType& right );
```

而**第一个操作数就是调用该操作符的对象的引用**，**第二个操作数是传进来的参数**，所以，如果要重载<<运算符，一般写法是这样的

```csharp
ostream& operator<<(ostream& os, const classType& obj);
```

则**第一个参数是该运算符的第一个操作数，然而，却不是类对象**，
所以当该类运算符重载时写在类的内部时，又为了访问类内除public外的其它变量或函数

[C++中友元函数和成员函数的区别-CSDN博客](https://blog.csdn.net/dandanzmc/article/details/11660897)



## 关于protected和private

在C++中，`private`和`protected`是两种不同的访问修饰符，它们控制类成员的访问权限。

- `private`：私有成员只能被该类的成员函数和友元函数访问，不能被该类的对象或者任何其他类访问。
- `protected`：受保护成员可以被该类的成员函数、该类派生出的子类的成员函数以及友元函数访问，但不能被该类的对象访问。

在你的代码中，`object`类的成员`a`是私有的，所以它只能被`object`类的成员函数和友元函数访问。如果你想让`a`能被`object`类派生出的子类访问，你应该将`a`声明为受保护的，例如：

```cpp
class object {
public:
    object() {
        a = 0;
    }
protected:
    int a;
};
```

在这个例子中，`a`是受保护的，所以它可以被`object`类的成员函数、`object`类派生出的子类的成员函数以及友元函数访问。

## 虚函数和static互斥,static函数也不能加const

#### 虚函数

- **与对象关联**：虚函数是与具体的对象实例关联的，它们通过对象的虚函数表（vtbl）实现动态绑定。
- **需要对象上下文**：调用虚函数时，需要知道具体对象的类型，以便调用正确的函数实现。这需要通过`this`指针来访问对象的状态和虚函数表。

#### 静态成员函数

- **与类关联**：静态成员函数是与类本身关联的，而不是与具体的对象实例关联的。
- **没有对象上下文**：静态成员函数没有`this`指针，不能访问对象的非静态成员或虚函数表，因为它们在类层次上调用，而不是通过对象。

#### 简单总结

- **虚函数**：需要对象实例来确定调用哪个函数实现。
- **静态成员函数**：不依赖任何对象实例，只能访问类的静态成员。

由于虚函数依赖于对象的上下文，而静态成员函数没有对象上下文，因此它们不能结合在一起使用。虚函数需要对象实例和虚函数表，而静态成员函数不具备这些特性，因此它们是互斥的。

#### 为何static成员函数不能为const函数 

当声明一个非静态成员函数为const时，对this指针会有影响。对于一个Test类中的const修饰的成员函数，this指针相当于Test const *, 而对于非const成员函数，this指针相当于Test *.  而static成员函数没有this指针，所以使用const来修饰static成员函数没有任何意义。  volatile的道理也是如此。

## 关于new运算符

new运算符做的三件事：获得一块内存空间、调用构造函数、返回正确的指针

#### New运算符的使用方法：

1、new() ：分配这种类型的一个大小的内存空间,并以括号中的值来初始化这个变量;

2、 new[] ：分配这种类型的n个大小的内存空间,并用默认构造函数来初始化这些变量;  

char* p=new char[6];   strcpy(p,"Hello");

3、当使用new运算符定义一个多维数组变量或数组对象时，它产生一个指向数组第一个元素的指针，返回的类型保持了除最左边维数外的所有维数。例如：  

```cpp
int *p1 = new int[10];

返回的是一个指向int的指针int*  

int (*p2)[10] = new int[2][10];

new了一个二维数组, 去掉最左边那一维[2], 剩下int[10], 所以返回的是一个指向int[10]这种一维数组的指针int (*)[10].  

int (*p3)[2][10] = new int[5][2][10];

 new了一个三维数组, 去掉最左边那一维[5], 还有int[2][10], 所以返回的是一个指向二维数组int[2][10]这种类型的指针int (*)[2][10].
```

4、创建类对象

1）new创建对象，pTest用来接收对象指针。new申请的对象，则只有调用到delete时才会执行析构函数，如果程序退出而没有执行delete则会造成内存泄漏：

CTest*  pTest = new  CTest();  delete pTest;

2）不用new，直接使用类定义申明，使用完后不需要手动释放，该类析构函数会自动执行：

CTest  mTest;

3）使用普通方式创建的类对象，在创建之初就已经分配了内存空间。而类指针，如果未经过对象初始化，则不需要delete释放：

CTest*  pTest = NULL;

## 作用域运算符::

 ::是运算符中等级最高的，它分为三种：全局作用域符，类作用域符，命名空间作用域符

### 全局作用

全局作用域符号：当全局变量在局部函数中与其中某个变量重名，那么就可以用::来区分如： 

```cpp
char zhou; //全局变量 
　　void sleep（） 
　　{ 
　　char zhou; //局部变量 
　　zhou(局部变量) = zhou(局部变量) *zhou(局部变量) ; 
　　::zhou(全局变量) =::zhou(全局变量) *zhou(局部变量); 
}
```

### 类作用

作用域符号::的前面一般是类名称，后面一般是该类的成员名称，C++为了避免不同的类有名称相同的成员而采用作用域的方式进行区分
　　如：A,B表示两个类，在A,B中都有成员member。那么
　　A::member就表示类A中的成员member
　　B::member就表示类B中的成员member

### 命名空间

"::"是作用域[限定符](http://baike.baidu.com/view/6987276.htm)或者称作用域运算符或者作用域操作符（scope operator）.例如命名空间

"::"作用：

```cpp
namespace::name
```

###   :: 的另一种用法

  直接用在全局函数前，表示是全局函数。

## 关于缺省值函数

在C++中，函数形参的缺省值（默认值）有以下规则：

缺省值必须从右向左连续设定。也就是说，如果一个参数有缺省值，那么它右边的所有参数都必须有缺省值。例如，以下函数声明是合法的：

```cpp
void fun(int x, int y = 1, int z = 2);
```

但是，以下函数声明是非法的，因为`y`有缺省值，但是它右边的参数`z`没有缺省值：

```cpp
void fun(int x, int y = 1, int z); // 非法
```

缺省值只能在函数声明时设定，不能在函数定义时设定。例如，以下代码是合法的：

```cpp
// 在函数声明时设定缺省值
void fun(int x = 0);
// 函数定义
void fun(int x) {
  // ...
}
但是，以下代码是非法的，因为缺省值在函数定义时设定：
// 函数声明
void fun(int x);
// 在函数定义时设定缺省值
void fun(int x = 0) { // 非法
  // ...
}
```

如果函数在同一作用域内多次声明，那么它的每个参数的缺省值最多只能设定一次。但是，如果函数在不同的作用域内声明，那么在不同的作用域内可以给同一个参数设定不同的缺省值。

## 关于try和catch





## 多态

**动态多态**

  运行时的多态存在于继承类中，通过虚函数现动态选择调用。

**静态多态**

  静态多态是发生在编译时期的，通过**模板和函数重载**实现，相比动态多态不需派生关系。



## C++文件操作

[C++文件操作（2023最新详解）-CSDN博客](https://blog.csdn.net/weixin_43256263/article/details/127502981)

1、要打开一个输入文件流，需要定义一个 **ifstream**类型的对象。->Input-stream
2、要打开一个输出文件流，需要定义一个 **ofstream**类型的对象。->Output-stream
3、如果要打开输入输出文件流，则要定义一个 **fstream**类型的对象。->File-stream

**这3种类型都定义在头文件 **fstream里

```cpp
ofstream ofs;   		  //2、打开一个相应的文件流
ofs.open("mytest.txt");	  //3、流与文件关联上
```

因为**ifstream**、**ofstream**和**fstream**这3个类都具有**自动打开文件的构造函数**，而这个构造函数就具有 **open()** 的功能。

因此，我们可以在创建流对象的时候就可以关联文件：`ofstream myStream("myText.txt");`

**open函数的原型如下**：

```cpp
void open(char const *,int filemode,int =filebuf::openprot);
```

| ios::in     | 打开文件进行读操作，这种方式可避免删除现存文件的内容         |
| ----------- | ------------------------------------------------------------ |
| ios::out    | 打开文件进行写操作，这是默认模式                             |
| ios::ate    | 打开一个已有的输入或输出文件并查找到文件尾开始               |
| ios::app    | 在文件尾追加方式写文件                                       |
| ios::binary | 指定文件以二进制方式打开，默认为文本方式                     |
| ios::trunc  | 如文件存在，将其长度截断为零并清除原有内容，如果文件存在先删除，再创建 |







## 三种继承

### 1.公有继承–public:（原样复制）

公有继承时，对基类的`公有成员和保护成员`的`访问属性不变`，派生类的新增成员只能访问基类的`公有成员和保护成员`**（都一样）**。派生类的对象`只能访问派生类的公有成员`（包括继承的公有成员），访问不了保护成员和私有成员**（公有继承的对象多了个访问继承的公有成员）**。

### 2.保护继承–protected

保护继承中，基类的`公有成员和保护成员`被派生类继承后变成`保护成员`，派生类的新增成员只能访问基类的`公有成员和保护成员`**（都一样）**，派生类的对象`只能访问派生类的公有成员`。

### 3.私有继承–private

私有继承时，基类的`公有成员和保护成员`都被派生类继承下来之后变成`私有成员`，派生类的新增成员只能访问基类的`公有成员和保护成员`**（都一样）**。派生类的对象`只能访问派生类的公有成员`**(这里和protected继承一样)**。

## 关于多继承

[C++多继承中的二义性问题_c++多重继承引起的二义性问题-CSDN博客](https://blog.csdn.net/buknow/article/details/80436010)

#### 同名二义性

一个子类继承两个有同名数据成员的父类

#### 路径二义性

一个子类继承两个父类，这两个父类又继承自同一个祖父类

